import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

from k_means import Kmeans
from kernel_pca import kernelPCA


class spectralKmeans():
    """Spectral clustering algorithm

    Working:
        - Data is loaded from a .csv file (data as row vectors)
        - Kernel matrix is computed [Choose Kernel]
        - K top eigenvectors of kernel matrix are chosen
        - Clusters are generated by clustering on normalized rows 
        of the eigenvectors [Choose Initialization]

    Initialization (for spectral clustering):
        - "random"
        - "Kmeans++"

    Kernels:
        - "radial basis"
        - "polynomial"
        - "custom"
        - "none" (standard inner product)
    """

    def __init__(self, data_file, num_clusters, kernel, seed, params, initialize_method="random", cluster_method="Kmeans") -> None:

        self.kernel_type = kernel
        self.params = params
        self.initialize_method = initialize_method
        self.generate_cluster = {"Kmeans": self.kmeans_clusters,
                                 "max": self.max_clusters}
        self.cluster_method = cluster_method

        self.data_file = data_file
        self.k = num_clusters

        self.seed = seed

        self.colors = cm.tab20(range(2*self.k))

        self.z = None

    def load_data(self, data_file):
        self.data = np.loadtxt(data_file, delimiter=',')
        self.arr = self.data.astype(float)

        self.num_points = self.arr.shape[0]
        self.dims = self.arr.shape[1]

    def compute_clusters(self):

        kpc = kernelPCA(data_file=None,
                        kernel=self.kernel_type,
                        params=self.params,
                        ext_data=self.arr)
        kpc.run()

        self.h = np.fliplr(kpc.beta[-self.k:, :].T)

        self.generate_cluster[self.cluster_method]()

    def kmeans_clusters(self):

        for i in range(self.num_points):
            self.h[i] = self.h[i]/(np.linalg.norm(self.h[i]))

        self.km = Kmeans(data_file=None,
                         num_clusters=self.k,
                         seed=self.seed,
                         initialize_method=self.initialize_method,
                         ext_data=self.h)
        self.km.run()

        self.z = self.km.z_cur
        self.errors = self.km.errors

    def max_clusters(self):
        self.z = np.zeros((self.num_points), dtype=int)
        for i in range(self.num_points):
            self.z[i] = np.argmax(self.h[i])

    def plot_kmeans_data(self):
        circle = plt.Circle((0, 0), 1, fill=False)
        plt.subplot(1, 2, 1).add_patch(circle)
        self.km.plot_data()

        plt.subplot(1, 2, 1)
        plt.xlabel(
            r"$\frac{\alpha_1}{\sqrt{\alpha_1^2+\alpha_2^2}}$", fontsize=15)
        plt.ylabel(
            r"$\frac{\alpha_2}{\sqrt{\alpha_1^2+\alpha_2^2}}$", fontsize=15)

    def plot_data(self):

        plt.grid('on')
        plt.xlabel(r"$x$", fontsize=15)
        plt.ylabel(r"$y$", fontsize=15)
        for i in range(self.num_points):
            plt.plot(self.arr[i, 0], self.arr[i, 1], '.',
                     color=self.colors[2*self.z[i]])

    def run(self):

        self.load_data(self.data_file)
        self.compute_clusters()


if __name__ == '__main__':

    data_file = "../data/cm_dataset_2 - cm_dataset.csv"

    sk = spectralKmeans(data_file=data_file,
                        num_clusters=2,
                        kernel='custom',
                        seed=1,
                        params={"d": 3,
                                "z": 9,
                                "sigma": 1.3},
                        initialize_method="random",
                        cluster_method="Kmeans")
    sk.run()
    sk.plot_data()
    plt.show()
